# 瑞吉外卖

## 登录与退出

```java
/**
 * <p>
 * 员工信息 前端控制器
 * </p>
 *
 * @author 点点君
 * @since 2022-10-08
 */
@RestController
@RequestMapping("/employee")
@Slf4j
public class EmployeeController {
    @Autowired
    private EmployeeService employeeService;

    /**
     * 员工登录
     * @param employee 前台发送来的数据，封装成一个对象
     * @param request 向前台共享数据
     * @return
     */
    @PostMapping("/login")
    public R<Employee> login(@RequestBody Employee employee, HttpServletRequest request){
        //1. 将页面提交的代码进行md5加密
        String password = employeeService.md5Digest(employee.getPassword());
        //2. 根据页面提交的用户名userName查询数据库
        LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Employee::getUsername,employee.getUsername());
        Employee emp = employeeService.getOne(queryWrapper);
        if(emp==null){
            return R.error("登陆失败");
        }
        //3. 密码比对
        if(!emp.getPassword().equals(password)){
            return R.error("密码错误");
        }
        //4. 判断用户当前状态
        if(emp.getStatus()==0){
            return R.error("账号已禁用");
        }
        //5. 登陆成功，将员工id存入Session并返回登陆成功的结果
        HttpSession session = request.getSession();
        session.setAttribute("employee",emp.getId());
        return R.success(emp);
    }

    /**
     * 员工退出
     * @param request
     * @return
     */
    @PostMapping("/logout")
    public R<String> logout(HttpServletRequest request){
        HttpSession session = request.getSession();
        session.removeAttribute("employee");
        return R.success("退出成功");
    }
}
```

### 加密操作

```java
/**
* @author 17305
* @description 针对表【employee(员工信息)】的数据库操作Service实现
* @createDate 2022-10-12 21:20:01
*/
@Service
public class EmployeeServiceImpl extends ServiceImpl<EmployeeMapper, Employee>
    implements EmployeeService{
    @Override
    public String md5Digest(String password) {
        return DigestUtils.md5DigestAsHex(password.getBytes());
    }
}

```

### 登录校验

```java
@WebFilter(filterName = "loginCheckFilter",urlPatterns = "/*")
@Slf4j
public class LoginCheckFilter implements Filter {
    //路径匹配器，支持通配符
    public static final AntPathMatcher PATH_MATCHER=new AntPathMatcher();

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        String requestURI = request.getRequestURI();
        //定义不需要处理的请求路径
        String[] urls = {"/employee/login", "/employee/logout", "/backend/**","front/**"};
        boolean check = check(urls, requestURI);
        if(check){
            //放行
            filterChain.doFilter(request,response);
            return;
        }
        //判断是否登录
      //从session中获取登录信息
        if(request.getSession().getAttribute("employee")!=null){
            //放行
            filterChain.doFilter(request,response);
            return;
        }
        //如果未登录
        response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));
        return;
    }

    /**
     * 路径匹配，检查本次请求是否需要放行
     * @param urls
     * @param requestURI
     * @return
     */
    public boolean check(String[] urls , String requestURI){
        for(String url:urls){
            boolean match = PATH_MATCHER.match(url, requestURI);
            if(match){
                return true;
            }
        }
        return false;
    }
}

```

## 添加员工

```java
/**
 * 添加员工
 * @param employee 前端获取的员工信息
 * @param request 请求信息，用于获取请求域中的属性
 * @return 返回响应结果
 */
@PostMapping
public R<String> addEmployee(@RequestBody Employee employee,HttpServletRequest request){
    employee.setPassword(employeeService.md5Digest("123456"));
    employee.setStatus(1);
    employee.setCreateTime(new Date());
    employee.setUpdateTime(new Date());
    Long empId = (Long) request.getSession().getAttribute("employee");
    employee.setCreateUser(empId);
    employee.setUpdateUser(empId);
    employeeService.save(employee);
    return R.success("添加成功");
}
```

### 全局异常处理器

```java
@ControllerAdvice(annotations = {RestController.class, Controller.class})
@ResponseBody
public class GlobalExceptionHandler {
    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)
    public R<String> addEmployeeException(SQLIntegrityConstraintViolationException sqlIntegrityConstraintViolationException){
        String message = sqlIntegrityConstraintViolationException.getMessage();
        if(message.contains("Duplicate entry")){
            String[] split = message.split(" ");
            return R.error(split[2]+"已存在");
        }else{
            return R.error("未知错误");
        }
    }
}
```

## 员工信息分页

### 配置MybatisPlus的分页插件

通过MybatisPlus的Interceptor来配置

```java
@Configuration
public class MybatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return mybatisPlusInterceptor;
    }
}
```

### 获取分页信息

```java
/**
* 获取分页信息
* @param page 当前第几页
* @param pageSize 每页多少条数据
* @param name 有无模糊查询
* @return 返回分页信息
*/
@GetMapping("/page")
public R<Page<Employee>> page(int page, int pageSize, String name){
    //构造分页构造器
    Page<Employee> pageInfo = new Page<>(page, pageSize);
    //构造条件构造器
    LambdaQueryWrapper<Employee> employeeQueryWrapper = new LambdaQueryWrapper<>();
    //添加过滤条件
    employeeQueryWrapper.like(!StringUtils.isEmpty(name),Employee::getName,name);
    employeeQueryWrapper.orderByDesc(Employee::getUpdateTime);
    //执行查询
    employeeService.page(pageInfo,employeeQueryWrapper);
    return R.success(pageInfo);
}
```

> 在service执行完查询操作后，会自动将数据和信息封装到我们自定义的page对象中

## 修改员工信息

```java
/**
 * 更新员工信息
 * @param employee 前端发送的员工信息
 * @param request 通过request获取session作用域中的登录信息，从而得知更新人的ID
 * @return 返回修改情况
 */
@PutMapping
public R<String> update(@RequestBody Employee employee,HttpServletRequest request){
    //由于更新了信息，故属性中的更新时间和更新人也要发生改变
    Long empId = (Long) request.getSession().getAttribute("employee");
    employee.setUpdateTime(new Date());
    employee.setUpdateUser(empId);
    //更新信息
    employeeService.updateById(employee);
    return R.success("修改成功");
}
```

> 由于后端通过雪花算法生成的ID过长，导致传到前端时会损失精度，因此需要通过消息转换器，将后台Long类型的id转换成String类型发送到前台，同时前台发送String类型的id到后台时，也重新将它转换为Long类型

### 配置一个对象映射器

```java
/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);


        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))

                .addSerializer(BigInteger.class, ToStringSerializer.instance)
                .addSerializer(Long.class, ToStringSerializer.instance)
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}
```

### 在WebMvcConfig中扩展消息转换器

```java
/**
 * 扩展MVC框架的消息转换器
 * @param converters MVC原先默认的转换器
 */
@Override
protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
    //创建消息转换器对象
    MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
    //设置对象转换器，底层使用Jackson将java对象转为json
    converter.setObjectMapper(new JacksonObjectMapper());
    //将这个消息转换器追加到默认的转换器中
  	//应该放在第一个，这样处理数据的时候才会先用我们自己定义的消息转换器
    converters.add(0,converter);
}
```

### 跳转到修改页面并获取到用户信息

```java
/**
* 跳转到修改页，通过数据库查询到对应员工的信息并填入
* @param id 对应员工的id
* @return 对应员工的所有信息
*/
@GetMapping("/{id}")
public R<Employee> updatePage(@PathVariable Long id){
  Employee employee = employeeService.getById(id);
  return R.success(employee);
}
```

## 菜品分类

### 公共字段自动填充

1. 在实体类属性上加入@TableField注解，指定自动填充策略

```java
/**
 * 创建时间
 */
@TableField(fill = FieldFill.INSERT)//插入时填充字段
private Date createTime;

/**
 * 更新时间
 */
@TableField(fill = FieldFill.INSERT_UPDATE)//插入与修改时填充字段
private Date updateTime;

/**
 * 创建人
 */
@TableField(fill = FieldFill.INSERT)//插入时填充字段
private Long createUser;

/**
 * 修改人
 */
@TableField(fill = FieldFill.INSERT_UPDATE)//插入与修改时填充字段
private Long updateUser;

```

2. 按照框架要求编写元数据对象处理器，在此统一为公共字段赋值，此类需要实现MetaObjectHandler接口

```java
/**
 * 自定义的元数据对象处理器
 */
@Component
@Slf4j
public class MyMetaObjectHandler implements MetaObjectHandler {
    @Override
    public void insertFill(MetaObject metaObject) {
        metaObject.setValue("createTime",new Date());
        metaObject.setValue("updateTime",new Date());
        metaObject.setValue("createUser",new Long(1));
        metaObject.setValue("updateUser",new Long(1));
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        metaObject.setValue("updateTime",new Date());
        metaObject.setValue("updateUser",new Long(1));
    }
}
```

在元数据对象处理器中要获取session中的值需要用到ThreadLocal，因为同一个请求中的整个过程都是由同一个线程来完成的，因此可以在过滤器部分就将Session存到ThreadLocal中，在元数据对象处理器中取出session，这样就能获得session中的登录信息，从而把修改人信息填充上去

####  1.ThreadLocal是什么？

从名字我们就可以看到`ThreadLocal` 叫做本地线程变量，意思是说，`ThreadLocal` 中填充的的是当前线程的变量，该变量对其他线程而言是封闭且隔离的，`ThreadLocal` 为变量在每个线程中创建了一个副本，这样每个线程都可以访问自己内部的副本变量。

从字面意思很容易理解，但是实际角度就没那么容易了，作为一个面试常问的点，使用场景也是很丰富。

- 1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。
- 2、线程间数据隔离
- 3、进行事务操作，用于存储线程事务信息。
- 4、数据库连接，`Session`会话管理。

现在相信你已经对`ThreadLocal`有一个大致的认识了，下面我们看看如何用？

#### 2. ThreadLocal怎么用？

下面让我们来看一个例子：

```java
public class ThreadLocalTest02 {

    public static void main(String[] args) {

        ThreadLocal<String> local = new ThreadLocal<>();

        IntStream.range(0, 10).forEach(i -> new Thread(() -> {
            local.set(Thread.currentThread().getName() + ":" + i);
            System.out.println("线程：" + Thread.currentThread().getName() + ",local:" + local.get());
        }).start());
    }
}

输出结果：
线程：Thread-0,local:Thread-0:0
线程：Thread-1,local:Thread-1:1
线程：Thread-2,local:Thread-2:2
线程：Thread-3,local:Thread-3:3
线程：Thread-4,local:Thread-4:4
线程：Thread-5,local:Thread-5:5
线程：Thread-6,local:Thread-6:6
线程：Thread-7,local:Thread-7:7
线程：Thread-8,local:Thread-8:8
线程：Thread-9,local:Thread-9:9
```

从结果可以看到，每一个线程都有自己的local 值，这就是TheadLocal的基本使用 。

下面我们从源码的角度来分析一下，ThreadLocal的工作原理。

#### 3. ThreadLocal源码分析

1、`set` 方法

```java
/**
     * Sets the current thread's copy of this thread-local variable
     * to the specified value.  Most subclasses will have no need to
     * override this method, relying solely on the {@link #initialValue}
     * method to set the values of thread-locals.
     *
     * @param value the value to be stored in the current thread's copy of
     *        this thread-local.
     */
    public void set(T value) {
        //首先获取当前线程对象
        Thread t = Thread.currentThread();
        //获取线程中变量 ThreadLocal.ThreadLocalMap
        ThreadLocalMap map = getMap(t);
        //如果不为空，
        if (map != null)
            map.set(this, value);
        else
            //如果为空，初始化该线程对象的map变量，其中key 为当前的threadlocal 变量
            createMap(t, value);
    }

    /**
     * Create the map associated with a ThreadLocal. Overridden in
     * InheritableThreadLocal.
     *
     * @param t the current thread
     * @param firstValue value for the initial entry of the map
     */
//初始化线程内部变量 threadLocals ，key 为当前 threadlocal
    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }

       /**
         * Construct a new map initially containing (firstKey, firstValue).
         * ThreadLocalMaps are constructed lazily, so we only create
         * one when we have at least one entry to put in it.
         */
        ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
            table = new Entry[INITIAL_CAPACITY];
            int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
            table[i] = new Entry(firstKey, firstValue);
            size = 1;
            setThreshold(INITIAL_CAPACITY);
        }


 static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
```

汇总下，`ThreadLocalMap` 为 `ThreadLocal` 的一个静态内部类，里面定义了`Entry` 来保存数据。而且是继承的弱引用。在`Entry`内部使用`ThreadLocal`作为`key`，使用我们设置的`value`作为`value`。

对于每个线程内部有个`ThreadLocal.ThreadLocalMap` 变量，存取值的时候，也是从这个容器中来获取。

2、`get`方法

```java
/**
     * Returns the value in the current thread's copy of this
     * thread-local variable.  If the variable has no value for the
     * current thread, it is first initialized to the value returned
     * by an invocation of the {@link #initialValue} method.
     *
     * @return the current thread's value of this thread-local
     */
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
```

通过上面的分析，相信你对该方法已经有所理解了，首先获取当前线程，然后通过`key threadlocal` 获取 设置的`value` 。

#### 4. ThreadLocal 内存泄漏问题

我们首先来看下，下面这个类：

```java
/**
         * The entries in this hash map extend WeakReference, using
         * its main ref field as the key (which is always a
         * ThreadLocal object).  Note that null keys (i.e. entry.get()
         * == null) mean that the key is no longer referenced, so the
         * entry can be expunged from table.  Such entries are referred to
         * as "stale entries" in the code that follows.
         */
        static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
```

注释说的很清楚了，`Note that null keys (i.e. entry.get()* == null)`

如果 `key threadlocal` 为 `null` 了，这个 `entry` 就可以清除了。

`ThreadLocal`是一个弱引用，当为`null`时，会被当成垃圾回收 。

![img](https://pic4.zhimg.com/v2-50b25a5f65fe02d6eebe27801a94c833_b.jpg)

**重点来了，突然我们ThreadLocal是null了，也就是要被垃圾回收器回收了，但是此时我们的ThreadLocalMap（thread 的内部属性）生命周期和Thread的一样，它不会回收，这时候就出现了一个现象。那就是ThreadLocalMap的key没了，但是value还在，这就造成了内存泄漏。**

解决办法：使用完`ThreadLocal`后，执行`remove`操作，避免出现内存溢出情况。

所以 如同 `lock` 的操作 最后要执行解锁操作一样，`ThreadLocal`使用完毕一定记得执行remove 方法，清除当前线程的数值。

如果不`remove` 当前线程对应的`VALUE` ,就会一直存在这个值。

使用了线程池，可以达到“线程复用”的效果。但是归还线程之前记得清除`ThreadLocalMap`，要不然再取出该线程的时候，`ThreadLocal`变量还会存在。这就不仅仅是内存泄露的问题了，整个业务逻辑都可能会出错。

#### 5. 为什么key使用弱引用？

如果使用强引用，当`ThreadLocal` 对象的引用（强引用）被回收了，`ThreadLocalMap`本身依然还持有`ThreadLocal`的强引用，如果没有手动删除这个key ,则`ThreadLocal`不会被回收，所以只要当前线程不消亡，`ThreadLocalMap`引用的那些对象就不会被回收， 可以认为这导致`Entry`内存泄漏。

附：强引用-软引用-弱引用

- 强引用：普通的引用，强引用指向的对象不会被回收；
- 软引用：仅有软引用指向的对象，只有发生gc且内存不足，才会被回收；
- 弱引用：仅有弱引用指向的对象，只要发生gc就会被回收。

```java
/**
 * 基于ThreadLocal封装的工具类，用户保存和获取当前登录用户的id
 */
public class BaseContext {
    private static ThreadLocal<Long> threadLocal=new ThreadLocal<>();
    
    public static void setCurrentId(Long id){
        threadLocal.set(id);
    }
    
    public static Long getCurrentId(){
        return threadLocal.get();
    }
}
```

在过滤器判断成功登录后，将id存入线程中

```java
//将id存到当前线程中
Long empId = (Long) request.getSession().getAttribute("employee");
BaseContext.setCurrentId(empId);
```

在元数据对象处理器中获取

```java
/**
 * 自定义的元数据对象处理器
 */
@Component
@Slf4j
public class MyMetaObjectHandler implements MetaObjectHandler {
    @Override
    public void insertFill(MetaObject metaObject) {
        metaObject.setValue("createTime",new Date());
        metaObject.setValue("updateTime",new Date());
        metaObject.setValue("createUser",BaseContext.getCurrentId());
        metaObject.setValue("updateUser",BaseContext.getCurrentId());
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        metaObject.setValue("updateTime",new Date());
        metaObject.setValue("updateUser",BaseContext.getCurrentId());
    }
}
```

### 新增分类

```java
/**
 * 新增菜品/套餐分类
 * @param category 前端获取的分类数据
 * @return 返回保存情况
 */
@PostMapping
public R<String> save(@RequestBody Category category){
    categoryService.save(category);
    return R.success("新增分类成功");
}
```

#### 分页查询

```java
/**
* 获取分页信息
* @param page 当前第几页
* @param pageSize 每页多少条数据
* @return 分页信息与数据
*/
@GetMapping("/page")
public R<Page<Category>> getPage(int page, int pageSize){
  Page<Category> categoryPage = new Page<>(page, pageSize);
  LambdaQueryWrapper<Category> categoryLambdaQueryWrapper = new LambdaQueryWrapper<>();
  categoryLambdaQueryWrapper.orderByAsc(Category::getSort);
  categoryService.page(categoryPage,categoryLambdaQueryWrapper);
  return R.success(categoryPage);
}
```

### 删除菜品分类

#### 控制层

```java
/**
* 根据id删除分类，但是关联了菜品和套餐的分类不能删除
* @param ids 分类的id
* @return 处理情况
*/
@DeleteMapping
public R<String> delete(Long ids){
    categoryService.remove(ids);
    return R.success("删除成功");
}
```

####业务层

```java
/**
 * 根据id来删除分类，但在删除前要先查询是否有菜品和套餐关联了该分类
 * @param id 要删除的分类的id
 */
@Override
public void remove(Long id) {
    //查询是否有菜品关联了此分类
    LambdaQueryWrapper<Dish> dishLambdaQueryWrapper = new LambdaQueryWrapper<Dish>();
    dishLambdaQueryWrapper.eq(Dish::getCategoryId,id);
    long count = dishService.count(dishLambdaQueryWrapper);
    if(count>0){
        throw new CustomException("删除失败，当前分类关联了菜品");
    }
    //查询是否有套餐关联了此分类
    LambdaQueryWrapper<Setmeal> setmealLambdaQueryWrapper = new LambdaQueryWrapper<>();
    setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);
    count = setmealService.count(setmealLambdaQueryWrapper);
    if(count>0){
        throw new CustomException("删除失败，当前分类关联了套餐");
    }
    removeById(id);
}
```

#### 自定义异常类

```java
public class CustomException extends RuntimeException {
    public CustomException(String message){
        super(message);
    }
}
```

####在全局异常处理器中捕获该异常并进行处理

```java
@ExceptionHandler(CustomException.class)
public R<String> deleteCategoryException(CustomException customException){
    String message = customException.getMessage();
    return R.error(message);
}
```

### 修改菜品分类

```java
/**
 * 根据id修改分类的信息
 * @param category 前端传来的分类实体
 * @return 返回修改结果
 */
@PutMapping
public R<String> update(@RequestBody Category category){
    categoryService.updateById(category);
    return R.success("修改成功");
}
```

## 文件上传与下载

### 文件上传

```java
/**
 * 文件的上传下载
 */
@RestController
@RequestMapping("/common")
@Slf4j
public class CommonController {
    @Value("${reggie.path}")
    private String basePath;

    @PostMapping("/upload")
    public R<String> updateFile(MultipartFile file){
        //file是一个临时文件，需要转存到其他位置，否则本次请求结束后该文件会被删除
        //首先判断一下输出的目录是否存在
        File dir = new File(basePath);
        //如果不存在就创建这个目录
        if(!dir.exists()){
            dir.mkdirs();
        }
        //获得原始文件名
        String originalFilename = file.getOriginalFilename();
        //获得文件的后缀
        assert originalFilename != null;
        String suffix = originalFilename.substring(originalFilename.lastIndexOf('.') + 1);
        //与UUID随机生成的文件名连接，得到新的随机文件名
        String fileName = UUID.randomUUID() +suffix;
        try {
            file.transferTo(new File(basePath+fileName));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return R.success(fileName);
    }
}
```

### 文件下载

```java
/**
 * 文件下载
 * @param name 文件名
 * @param response 响应，用于将文件流写入传到浏览器
 */
@GetMapping("/download")
public void download(String name, HttpServletResponse response) {
    FileInputStream fileInputStream = null;
    ServletOutputStream outputStream = null;
    try {
        //通过输入流读取文件内容
        fileInputStream = new FileInputStream(new File(basePath + name));
        //通过输出流将文件写回到浏览器
        outputStream = response.getOutputStream();
        byte[] bytes = new byte[1024];
        int length = 0;
        while ((length = fileInputStream.read(bytes)) != -1) {
            outputStream.write(bytes, 0, length);
            outputStream.flush();
        }
        response.setContentType("image/type");
    } catch (IOException e) {
        throw new RuntimeException(e);
    } finally {
        try {
            fileInputStream.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        try {
            outputStream.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

## 添加菜品

### 获取全部分类数据

```java
/**
 * 获取分类数据
 * @param category 分类信息
 * @return 分类数据
 */
@GetMapping("/list")
public R<List<Category>> list(Category category){
    //添加条件构造器
    LambdaQueryWrapper<Category> categoryLambdaQueryWrapper = new LambdaQueryWrapper<>();
    //添加条件
    categoryLambdaQueryWrapper.eq(category.getType()!=null,Category::getType,category.getType());
    //添加排序条件
    categoryLambdaQueryWrapper.orderByAsc(Category::getSort);
    categoryLambdaQueryWrapper.orderByDesc(Category::getUpdateTime);
    List<Category> list = categoryService.list(categoryLambdaQueryWrapper);
    return R.success(list);
}
```

### 保存菜品

由于前端传来的数据过于复杂，需要用一个封装类来接收

```java
@Data
public class DishDto extends Dish {

    private List<DishFlavor> flavors = new ArrayList<>();

    private String categoryName;

    private Integer copies;
}
```

```java
/**
 * 将菜品存入数据库中，同时将其对应的口味也存入数据库中，在这之前先将菜品的id赋给其对应的口味
 * @param dishDto 浏览器传来的总数据
 */
@Override
@Transactional
public void saveWithFlavor(DishDto dishDto) {
    //先将菜品的内容存进数据库中
    save(dishDto);
    //将Flavor存入Flavor表中
    //先把当前菜品的id赋给flavor
    Long dishId = dishDto.getId();
    for (DishFlavor flavor : dishDto.getFlavors()) {
        flavor.setDishId(dishId);
    }
    //调用FlavorService将这些Flavor存入数据库
    dishFlavorService.saveBatch(dishDto.getFlavors());
}
```

> 由于同时操作两张表，所以需要在方法上加入事务管理

```java
@Transactional
```
## 修改菜品

### 查询到对应菜品的数据

```java
/**
 * 根据id查询菜品信息和对应的口味信息
 * @param id 菜品id
 * @return 菜品数据
 */
@GetMapping("/{id}")
public R<DishDto> getInfo(@PathVariable Long id){
    DishDto dishDto = dishService.getByIdWithFlavor(id);
    return R.success(dishDto);
}
```

```java
@Override
public DishDto getByIdWithFlavor(Long id) {
    //查询菜品基本信息
    Dish dish = getById(id);
    //查询菜品口味信息
    LambdaQueryWrapper<DishFlavor> dishFlavorLambdaQueryWrapper = new LambdaQueryWrapper<>();
    dishFlavorLambdaQueryWrapper.eq(DishFlavor::getDishId,id);
    List<DishFlavor> list = dishFlavorService.list(dishFlavorLambdaQueryWrapper);
    //创建DishDto对象，将数据存进去
    DishDto dishDto = new DishDto();
    BeanUtils.copyProperties(dish,dishDto);
    dishDto.setFlavors(list);
    return dishDto;
}
```

### 修改

```java
@PutMapping
public R<String> update(@RequestBody DishDto dishDto){
    dishService.updateWithFlavor(dishDto);
    return R.success("修改成功");
}
```

```java
@Override
@Transactional
public void updateWithFlavor(DishDto dishDto) {
    //更新dish表的相关信息
    updateById(dishDto);
    //清理当前菜品对应的所有口味信息
    LambdaQueryWrapper<DishFlavor> dishFlavorLambdaQueryWrapper = new LambdaQueryWrapper<>();
    dishFlavorLambdaQueryWrapper.eq(DishFlavor::getDishId,dishDto.getId());
    dishFlavorService.remove(dishFlavorLambdaQueryWrapper);
    //添加提交过来的所有口味信息
    for (DishFlavor flavor : dishDto.getFlavors()) {
        flavor.setDishId(dishDto.getId());
    }
    dishFlavorService.saveBatch(dishDto.getFlavors());
}
```

# 移动端

## 过滤器

```java
//定义不需要处理的请求路径
String[] urls = {"/employee/login", "/employee/logout", "/backend/**","/front/**","/user/sendMsg","/user/login"};
```

```java
//判断移动端用户是否登录
if(request.getSession().getAttribute("user")!=null){

    //将id存到当前线程中
    Long userId = (Long) request.getSession().getAttribute("user");
    BaseContext.setCurrentId(userId);

    //放行
    filterChain.doFilter(request,response);
    return;
}
```

## 邮箱发送验证码

把代发邮箱的第一项POP3/[SMTP](https://so.csdn.net/so/search?q=SMTP&spm=1001.2101.3001.7020)服务开启，然后按照他的步骤获取授权码，并且记录下来

###导入邮箱依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
```
### 配置文件

```yaml
#邮件发送配置
spring.mail.default-encoding=UTF-8
spring.mail.host=smtp.qq.com
#邮箱号
spring.mail.username=输入你的邮箱号
#授权码
spring.mail.password=输入刚刚获得的授权码
#邮件发送安全配置
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
```

### 服务类

```java
@Service
public class MailService{

    @Value("${spring.mail.username}")
    private String from;

    @Autowired
    private JavaMailSender mailSender;

    Logger logger = LoggerFactory.getLogger(this.getClass());
	
    public void sendVertifyCode(String to, String title, String content){
        SimpleMailMessage message = new SimpleMailMessage();
        message.setFrom(from); //发送人
        message.setTo(to);   //收件人
        message.setSubject(title);  //邮件名
        message.setText(content);   //邮件内容（验证码）
        mailSender.send(message);
        logger.info("已经发送");
    }
}

```

### 验证码生成工具类

```java
public class ValidateImageCodeUtils {
    /**
     * 验证码难度级别 Simple-数字 Medium-数字和小写字母 Hard-数字和大小写字母
     */
    public enum SecurityCodeLevel {
        Simple, Medium, Hard
    }

    ;

    /**
     * 产生默认验证码，4位中等难度
     *
     * @return
     */
    public static String getSecurityCode() {
        return getSecurityCode(4, SecurityCodeLevel.Medium, false);
    }

    /**
     * 产生长度和难度任意的验证码
     *
     * @param length
     * @param level
     * @param isCanRepeat
     * @return
     */
    public static String getSecurityCode(int length, SecurityCodeLevel level, boolean isCanRepeat) {
        // 随机抽取len个字符
        int len = length;
        // 字符集合（--除去易混淆的数字0,1,字母l,o,O）
        char[] codes = {
                '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
                'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
        };
        // 根据不同难度截取字符串
        if (level == SecurityCodeLevel.Simple) {
            codes = Arrays.copyOfRange(codes, 0, 10);
        } else if (level == SecurityCodeLevel.Medium) {
            codes = Arrays.copyOfRange(codes, 0, 36);
        }
        // 字符集和长度
        int n = codes.length;
        // 抛出运行时异常
        if (len > n && isCanRepeat == false) {
            throw new RuntimeException(String.format("调用SecurityCode.getSecurityCode(%1$s,%2$s,%3$s)出现异常，" + "当isCanRepeat为%3$s时，传入参数%1$s不能大于%4$s", len, level, isCanRepeat, n));
        }
        // 存放抽取出来的字符
        char[] result = new char[len];
        // 判断能否出现重复字符
        if (isCanRepeat) {
            for (int i = 0; i < result.length; i++) {
                // 索引0 and n-1
                int r = (int) (Math.random() * n);
                // 将result中的第i个元素设置为code[r]存放的数值
                result[i] = codes[r];
            }
        } else {
            for (int i = 0; i < result.length; i++) {
                // 索引0 and n-1
                int r = (int) (Math.random() * n);
                // 将result中的第i个元素设置为code[r]存放的数值
                result[i] = codes[r];
                // 必须确保不会再次抽取到那个字符，这里用数组中最后一个字符改写code[r],并将n-1
                codes[r] = codes[n - 1];
                n--;
            }
        }
        return String.valueOf(result);
    }

    /**
     * 生成验证码图片
     *
     * @param securityCode
     * @return
     */
    public static BufferedImage createImage(String securityCode) {

        int codeLength = securityCode.length();//验证码长度

        int fontSize = 18;//字体大小

        int fontWidth = fontSize + 1;

        //图片宽高

        int width = codeLength * fontWidth + 6;
        int height = fontSize * 2 + 1;
        //图片

        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);

        Graphics2D g = image.createGraphics();

        g.setColor(Color.WHITE);//设置背景色

        g.fillRect(0, 0, width, height);//填充背景

        g.setColor(Color.LIGHT_GRAY);//设置边框颜色

        g.setFont(new Font("Arial", Font.BOLD, height - 2));//边框字体样式

        g.drawRect(0, 0, width - 1, height - 1);//绘制边框

        //绘制噪点

        Random rand = new Random();

        g.setColor(Color.LIGHT_GRAY);

        for (int i = 0; i < codeLength * 6; i++) {

            int x = rand.nextInt(width);

            int y = rand.nextInt(height);

            g.drawRect(x, y, 1, 1);//绘制1*1大小的矩形

        }

        //绘制验证码

        int codeY = height - 10;

        g.setColor(new Color(19, 148, 246));

        g.setFont(new Font("Georgia", Font.BOLD, fontSize));
        for (int i = 0; i < codeLength; i++) {
            double deg = new Random().nextDouble() * 20;
            g.rotate(Math.toRadians(deg), i * 16 + 13, codeY - 7.5);
            g.drawString(String.valueOf(securityCode.charAt(i)), i * 16 + 5, codeY);
            g.rotate(Math.toRadians(-deg), i * 16 + 13, codeY - 7.5);
        }

        g.dispose();//关闭资源
        return image;
    }

//    public static void main(String[] args) throws IOException {
//        String securityCode = ValidateImageCodeUtils.getSecurityCode();
//        System.out.println(securityCode);
//
//        BufferedImage image = ValidateImageCodeUtils.createImage(securityCode);
//        ImageIO.write(image, "png", new FileOutputStream("aa.png"));
//    }

}
```

### 控制类中接收消息与发送验证码

```java
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private UserService userService;
    @Autowired
    private MailService mailService;

    /**
     * 通过邮箱发送验证码
     * @param user 浏览器传来的用户信息，含邮箱
     * @param session 将验证码存在session域中，后面好验证登录
     * @return
     */
    @PostMapping("/sendMsg")
    public R<String> sendMsg(@RequestBody User user, HttpSession session){
        //获取邮箱
        String email = user.getEmail();
        //生成随机验证码
        String securityCode = ValidateImageCodeUtils.getSecurityCode();
        //调用api发送邮件
        String to = email;
        String title= "验证码";
        String context = "根据验证码"+securityCode+"登录瑞吉外卖客户端";
        mailService.sendVertifyCode(to,title,context);
      	session.setAttribute("code",securityCode);
        return R.success("验证码发送成功");
    }
}
```

## 根据分类查询套餐信息

```java
/**
 * 根据分类查询套餐信息
 * @param setmeal 分类id
 * @return 菜品信息
 */
@GetMapping("/list")
public R<List<Setmeal>> list(Setmeal setmeal){
    LambdaQueryWrapper<Setmeal> setmealLambdaQueryWrapper = new LambdaQueryWrapper<>();
    setmealLambdaQueryWrapper.eq(Setmeal::getStatus,setmeal.getStatus());
    setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,setmeal.getCategoryId());
    List<Setmeal> list = setmealService.list(setmealLambdaQueryWrapper);
    return R.success(list);
}
```

## 根据分类查询菜品信息（含口味）

```java
/**
 * 根据分类查询菜品信息,含口味
 * @param dish 分类id
 * @return 菜品信息
 */
@GetMapping("/list")
public R<List<DishDto>> list(Dish dish){
    LambdaQueryWrapper<Dish> dishLambdaQueryWrapper = new LambdaQueryWrapper<>();
    dishLambdaQueryWrapper.eq(Dish::getCategoryId,dish.getCategoryId());
    //只查询状态为1的，也就是正在售卖的菜品
    dishLambdaQueryWrapper.eq(Dish::getStatus,1);
    List<Dish> list = dishService.list(dishLambdaQueryWrapper);
    ArrayList<DishDto> dishDtoList = new ArrayList<>();
    //通过查询数据库，将每个dishDto的categoryName完善
    for (Dish dishInList : list) {
        Long dishId = dishInList.getId();
        LambdaQueryWrapper<DishFlavor> dishFlavorLambdaQueryWrapper = new LambdaQueryWrapper<>();
        dishFlavorLambdaQueryWrapper.eq(DishFlavor::getDishId,dishId);
        List<DishFlavor> dishFlavorList = dishFlavorService.list(dishFlavorLambdaQueryWrapper);
        DishDto dishDto = new DishDto();
        BeanUtils.copyProperties(dishInList,dishDto);
        dishDto.setFlavors(dishFlavorList);
        dishDtoList.add(dishDto);
    }
    return R.success(dishDtoList);
}
```

## 购物车

### 添加购物车

```java
@RestController
@RequestMapping("/shoppingCart")
public class ShoppingCartController {
    @Autowired
    private ShoppingCartService shoppingCartService;

  	/**
     * 添加购物车
     * @param shoppingCart 购物车信息
     * @return 返回状态
     */
    @PostMapping("/add")
    public R<ShoppingCart> add(@RequestBody ShoppingCart shoppingCart){
        //设置用户id
        Long userId = BaseContext.getCurrentId();
        shoppingCart.setUserId(userId);
        //查询当前菜品或套餐是否在购物车中
        LambdaQueryWrapper<ShoppingCart> shoppingCartLambdaQueryWrapper = new LambdaQueryWrapper<>();
        shoppingCartLambdaQueryWrapper.eq(ShoppingCart::getUserId,shoppingCart.getUserId());
        //先看传来的是菜品还是套餐
        Long dishId = shoppingCart.getDishId();
        if(dishId==null){
            //不是菜品，是套餐
            shoppingCartLambdaQueryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId());
        }else{
            //是菜品
            shoppingCartLambdaQueryWrapper.eq(ShoppingCart::getDishId,shoppingCart.getDishId());
        }
        ShoppingCart cart = shoppingCartService.getOne(shoppingCartLambdaQueryWrapper);
        //如果不存在，就存进去，如果存在就数量加一
        if(cart==null){
            shoppingCart.setNumber(1);
            shoppingCartService.save(shoppingCart);
            cart=shoppingCart;
        }else{
            Integer number = cart.getNumber();
            cart.setNumber(number+1);
            shoppingCartService.updateById(cart);
        }
        return R.success(cart);
    }
}
```

### 查看购物车

```java
@GetMapping("/list")
public R<List<ShoppingCart>> list(){
    Long currentId = BaseContext.getCurrentId();
    LambdaQueryWrapper<ShoppingCart> shoppingCartLambdaQueryWrapper = new LambdaQueryWrapper<>();
    shoppingCartLambdaQueryWrapper.eq(ShoppingCart::getUserId,currentId);
    List<ShoppingCart> list = shoppingCartService.list(shoppingCartLambdaQueryWrapper);
    return R.success(list);
}
```

### 减少份数

```java
/**
 * 减少一个购物车商品
 * @param shoppingCart 传来的dishId火折子setmealId
 * @return 返回购物车数据
 */
@PostMapping("/sub")
public R<ShoppingCart> sub(@RequestBody ShoppingCart shoppingCart){
    Long currentId = BaseContext.getCurrentId();
    LambdaQueryWrapper<ShoppingCart> shoppingCartLambdaQueryWrapper = new LambdaQueryWrapper<>();
    shoppingCartLambdaQueryWrapper.eq(ShoppingCart::getUserId,currentId);
    if(shoppingCart.getDishId()!=null){
        shoppingCartLambdaQueryWrapper.eq(ShoppingCart::getDishId,shoppingCart.getDishId());
    }else{
        shoppingCartLambdaQueryWrapper.eq(ShoppingCart::getDishId,shoppingCart.getSetmealId());
    }
    shoppingCart = shoppingCartService.getOne(shoppingCartLambdaQueryWrapper);
    if(shoppingCart.getNumber()==1){
        shoppingCartService.removeById(shoppingCart);
    }else{
        Integer number = shoppingCart.getNumber();
        shoppingCart.setNumber(number-1);
        shoppingCartService.updateById(shoppingCart);
    }
    return R.success(shoppingCart);
}
```

### 清空购物车

```java
/**
 * 清空购物车
 * @return 删除信息
 */
@DeleteMapping("clean")
public R<String> clean(){
    Long currentId = BaseContext.getCurrentId();
    LambdaQueryWrapper<ShoppingCart> shoppingCartLambdaQueryWrapper = new LambdaQueryWrapper<>();
    shoppingCartLambdaQueryWrapper.eq(ShoppingCart::getUserId,currentId);
    shoppingCartService.remove(shoppingCartLambdaQueryWrapper);
    return R.success("清空成功");
}
```

## 用户下单

```java
/**
* @author 17305
* @description 针对表【orders(订单表)】的数据库操作Service实现
* @createDate 2022-11-08 22:02:34
*/
@Service
public class OrdersServiceImpl extends ServiceImpl<OrdersMapper, Orders>
    implements OrdersService{

    private final ShoppingCartService shoppingCartService;
    private final UserService userService;
    private final AddressBookService addressBookService;
    private final OrderDetailService orderDetailService;

    @Autowired
    public OrdersServiceImpl(ShoppingCartService shoppingCartService, UserService userService, AddressBookService addressBookService, OrderDetailService orderDetailService) {
        this.shoppingCartService = shoppingCartService;
        this.userService = userService;
        this.addressBookService = addressBookService;
        this.orderDetailService = orderDetailService;
    }

    @Override
    @Transactional
    public void submit(Orders orders) {
        //获取用户的id
        Long currentId = BaseContext.getCurrentId();
        //获取该用户的购物车数据
        LambdaQueryWrapper<ShoppingCart> shoppingCartLambdaQueryWrapper = new LambdaQueryWrapper<>();
        shoppingCartLambdaQueryWrapper.eq(ShoppingCart::getUserId,currentId);
        List<ShoppingCart> list = shoppingCartService.list(shoppingCartLambdaQueryWrapper);
        if(list==null||list.size()==0){
            throw new CustomException("购物车为空，不能下单");
        }
        //查询用户数据
        User user = userService.getById(currentId);
        //查询地址数据
        AddressBook addressBook = addressBookService.getById(orders.getAddressBookId());
        if(addressBook==null){
            throw new CustomException("地址信息有误，不能下单");
        }
        //向订单表插入数据
        long orderId = IdWorker.getId();
        //订单明细数据
        List<OrderDetail> orderDetails = new ArrayList<>();
        //遍历购物车，算出购物车总金额
        AtomicInteger amount = new AtomicInteger(0);
        for (ShoppingCart item:list) {
            OrderDetail orderDetail = new OrderDetail();
            orderDetail.setOrderId(orderId);
            orderDetail.setNumber(item.getNumber());
            orderDetail.setDishFlavor(item.getDishFlavor());
            orderDetail.setDishId(item.getDishId());
            orderDetail.setSetmealId(item.getSetmealId());
            orderDetail.setName(item.getName());
            orderDetail.setImage(item.getImage());
            orderDetail.setAmount(item.getAmount());
            amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber())).intValue());
        }
        orders.setId(orderId);
        orders.setOrderTime(new Date());
        orders.setCheckoutTime(new Date());
        orders.setStatus(2);
        orders.setAmount(new BigDecimal(amount.get()));//总金额
        orders.setUserId(currentId);
        orders.setNumber(String.valueOf(orderId));
        orders.setUserName(user.getName());
        orders.setConsignee(addressBook.getConsignee());
        orders.setPhone(addressBook.getPhone());
        orders.setAddress((addressBook.getProvinceName() == null ? "" : addressBook.getProvinceName())
                + (addressBook.getCityName() == null ? "" : addressBook.getCityName())
                + (addressBook.getDistrictName() == null ? "" : addressBook.getDistrictName())
                + (addressBook.getDetail() == null ? "" : addressBook.getDetail()));
        this.save(orders);
        //向订单明细表插入数据
        orderDetailService.saveBatch(orderDetails);
        //清空购物车数据
        shoppingCartService.remove(shoppingCartLambdaQueryWrapper);
    }
}
```

```java
@RestController
@RequestMapping("/order")
public class OrdersController {
    @Autowired
    private OrdersService ordersService;

    @PostMapping("/submit")
    public R<String> submit(Orders orders){
        ordersService.submit(orders);
        return R.success("下单成功");
    }
}
```

