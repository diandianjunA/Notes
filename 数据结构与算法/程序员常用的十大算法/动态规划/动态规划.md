# 动态规划

动态规划算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法

与分治法不同的是，适用于动态规划的问题，经分解得到的子问题往往不是相互独立的（即下一子阶段的求解建立在上一子阶段的解的问题之上进行进一步求解）

## 背包问题

背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分为01背包和完全背包(完全背包是指每种物品都无限次可用)

### 思路分析

每次遍历到第i个物品，根据w[i]和v[i]来确定是否需将该物品放入背包中，即对于给定的第n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C表示背包的容量，再令v\[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值，则有以下结果

1. v\[i][0]=v\[0][j]=0 //表示第0行和第0列等于0
2. 当w[i]>j时，v\[i][j]=v\[i-1][j] //当准备加入的新增的商品容量大于当前背包的容量，就不装入，直接使用上一单元格的装入策略
3. 当j>=w[i]时，v\[i][j]=max{v\[i-1][j],v\[i-1][j-w[i]]+v[i]} //当准备加入的新增的商品的容量小于等于当前背包的容量，装入的策略为取以下两者的最大值
   1. 上一个单元的最优策略策略v\[i-1][j]
   2. 当前商品的价值v[i]+从j中取出w[i]重量之后背包内的价值v[i-1][j-w[i]](要保证此时背包内的总重量为j，所以你假设要装入该物品（重量为w[i]）时，就要取出w[i]的重量，也就是此时背包内的价值为v[i-1][j-w[i]]，即取出w[i]质量的物品后背包内的最大价值)

```java
public class KnapsackProblem {
    public static void main(String[] args) {
        int[] w={0,1,4,3};
        int[] val={0,1500,3000,2000};
        int n=val.length;//物品个数
        int m=4;//背包容量
        //用于记录背包内的最大价值
        int[][] v=new int[n][m+1];//表格纵坐标。0磅，1磅，2,磅，3磅，4磅，所以需要申请5个，也就是m+1个
        int[][] path=new int[n][m+1];//用于记录物品放入情况
        //初始化第0行和第0列
        for (int i = 0; i < v.length; i++) {
            v[i][0]=0;
        }
        for (int i = 0; i < v[0].length; i++) {
            v[0][i]=0;
        }
        //动态规划处理
        for (int i = 1; i < v.length; i++) {//不处理第0行，第0行认为是没有商品，全0
            for (int j = 1; j < v[i].length; j++) {//不处理第0列，第0列认为重量为0磅，自然也没有商品，价值为0
                if (w[i]>j){
                    v[i][j]=v[i-1][j];
                }else{
//                    v[i][j]=Math.max(v[i-1][j],val[i]+v[i-1][j-w[i]]);
                    if(v[i-1][j]>val[i]+v[i-1][j-w[i]]){
                        v[i][j]=v[i-1][j];
                    }else{
                        v[i][j]=val[i]+v[i-1][j-w[i]];
                        path[i][j]=1;
                    }
                }
            }
        }
        for (int[] arr:v) {
            System.out.println(Arrays.toString(arr));
        }
        System.out.println("=============");
        //这会输出所有的放入情况，但其实只需要最后的放入情况
//        for (int i = 0; i < path.length; i++) {
//            for (int j = 0; j < path[i].length; j++) {
//                if(path[i][j]==1){
//                    System.out.printf("第%d个商品放入背包中\n",i);
//                }
//            }
//        }
        int i= path.length-1;//行的最大下标
        int j= path[0].length-1;//列的最大下标
        while (i>=0&&j>=0){
            if (path[i][j]==1){
                System.out.printf("第%d个商品放入背包\n",i);
                j-=w[i];//从后往前遍历，发现某个商品放入后，直接跳到减去某个商品后的重量的位置，能直接得到剩下的商品的放入策略
            }
            i--;//由于一个商品只能放一次，所以i--
        }
    }
}
```

